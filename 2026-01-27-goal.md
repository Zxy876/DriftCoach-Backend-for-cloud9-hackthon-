DriftCoach — Interactive Inference Coach System
Engineering Goal v4.0（可落地版） · 2026-01-27

目标：在不破坏 central-data 事实宇宙的前提下，把「教练自然语言 → AI 推理 → 后端 Patch → EvidenceState 增长 → 分析器刷新」闭环做成可演示的 MVP，并留出迭代空间。

⸻

## 0. 冻结与约束（必须遵守）

- **唯一事实源**：`GRID_GRAPHQL_URL=https://api-op.grid.gg/central-data/graphql`
- **禁止补写 / 猜测**：不得伪造 outcome / round / score / stats。
- **Analyzer 冻结**：Insight / Review / What-if 逻辑、阈值不改；只吃 `EvidenceState`。
- **EvidenceState 是唯一输入**：不可补齐字段，不可造假，必须带 provenance。

⸻

## 1. 范围与非范围

- **在范围**
	- 新增 `/api/coach/query` 闭环：AI 推理 → Patch → EvidenceState → 分析刷新。
	- 前端新增 Coach Chat Panel（极简输入 + 回复），上半区分析面板仅刷新数据。
	- 实现 AI Inference Orchestrator（LLM prompt、输入输出 schema、判定充分/不足）。
	- Patch Executor（按白名单执行 central-data 查询/聚合，并写入 EvidenceState）。
	- 观测与追踪：记录 why/what/result per patch，返回 provenance 给前端。

- **不在范围**
	- 不修改 Analyzer 逻辑与阈值；不生成概率/胜负；不伪造数据。
	- 不做多轮对话管理（单轮请求-响应即可）；不做前端智能。

⸻

## 2. 架构落地（映射到当前仓库）

- Backend（Python / FastAPI）
	- 现有 `driftcoach/api.py` 暴露 `/api/demo`；新增 `/api/coach/query`。
	- `driftcoach/adapters/grid/*` 负责 central-data 查询与 state 构建，可复用 `build_plan/execute_plan/build_states`。
	- 新增模块：`driftcoach/llm/orchestrator.py`（封装 LLM 调用、prompt、schema 校验）。
	- 新增模块：`driftcoach/adapters/grid/patch_executor.py`（按 Patch 白名单执行并写入 EvidenceState）。

- Frontend（Vite + React + TypeScript）
	- 现有分析面板在 `frontend/components/*`；新增 `CoachChatPanel`（输入框 + 结果展示）。
	- 新增客户端调用 `POST /api/coach/query` 的 hook/service。

- Data Contracts
	- `InferenceInput` / `InferencePlan` JSON schema（后端验证 + 前端类型）。
	- `PatchType` 白名单与参数校验。
	- Response payload 增加 `assistant_message` 与 `context` 里的 provenance。

⸻

## 3. 交付物（Done 的标准）

- **API**：`POST /api/coach/query` 可调用，支持 mock 与 grid；失败路径返回不足原因。
- **AI 层**：LLM 输出严格符合 `InferencePlan` schema，拒绝未支撑的结论；判定充分/不足。
- **Patch 执行**：白名单六类 Patch 全部可执行（mock 走本地 fixtures，grid 走 central-data），写入 EvidenceState 并可追溯。
- **分析刷新**：每次 Patch 后重新跑 Analyzer，前端上半区面板数据随之刷新。
- **前端 UI**：新增 Coach Chat 输入 + AI 解释渲染，显示当前 context/schema/evidence 摘要。
- **观测**：日志至少包含 patch why/what/result、evidence counts、schema missing 字段；前端可看到 provenance。
- **文档**：README 补充约束、Patch 白名单、API 样例；本文件描述目标、范围、验收。

⸻

## 4. 核心 API 设计

### 4.1 请求

`POST /api/coach/query`

```json
{
	"coach_query": "如果在 Haven 22 回合我们选择保枪会不会更好？",
	"series_id": "2819676",
	"player_id": "91"
}
```

### 4.2 处理顺序（后端实现走这里）

1) `load_states_from_grid()` 或 mock fixtures → `states, context_meta`
2) 组装 `InferenceInput`（见 5.1）
3) 调用 `call_ai_inference(input) -> InferencePlan`
4) 若 `judgment == EVIDENCE_INSUFFICIENT`：
	 - 遍历 `proposed_patches` 按白名单执行，生成新的 EvidenceState，持久化并记录 provenance。
	 - 执行后重新加载 `states, context_meta`。
5) 跑 Analyzer：`insights, review, what_if = run_analyzers(states)`
6) 返回 payload：`context`（含 schema / evidence 摘要与 provenance）、`insights`、`review`、`whatIf`、`assistant_message`（AI 解释）。

### 4.3 响应示例（精简）

```json
{
	"context": {
		"schema": {"hasOutcome": false, "missing": ["Series.winner"]},
		"evidence": {
			"states": 12,
			"byType": {"AGGREGATED_PERFORMANCE": 3},
			"delta_states": 2,
			"delta_by_type": {"AGGREGATED_PERFORMANCE": 1},
			"patch_success_rate": 1.0
		},
		"provenance": [
			{"patch": "AGGREGATE_TEAM_STATISTICS", "status": "ok", "reason": "window=90d"}
		]
	},
	"inference_plan": {"judgment": "EVIDENCE_INSUFFICIENT", "rationale": "...<=600 chars", "proposed_patches": [...]},
	"patch_results": [
		{"patch": "AGGREGATE_TEAM_STATISTICS", "status": "ok", "trace_id": "abc", "origin": "ai-patch"}
	],
	"insights": [...],
	"review": [...],
	"whatIf": {...},
	"assistant_message": "证据不足，需补充 Haven 低经济 3v5 场景的历史聚合。已启动统计聚合。"
}
```

⸻

## 5. AI Inference Orchestrator（落地版）

### 5.1 输入 Schema（后端构造，前端无需提供除 query/ids 外的字段）

```ts
type InferenceInput = {
	coach_query: string;
	series_id?: string;
	player_id?: string;
	context: {
		schema: { hasOutcome: boolean; missing: string[] };
		evidence: { states_count: number; by_type: Record<string, number>; aggregation_available: boolean };
	};
	recent_evidence: EvidenceState[]; // 可截断，仅提供最近若干条
};
```

### 5.2 输出 Schema（LLM 必须严格符合）

```ts
type InferencePlan = {
	judgment: "EVIDENCE_SUFFICIENT" | "EVIDENCE_INSUFFICIENT";
	rationale: string; // 解释为何够/不够，<= 600 chars
	missing_evidence?: {
		concept: string;
		required_entity: string;
		reason: string;
	}[];
	proposed_patches?: PatchPlan[];
	confidence_note: string;
};

type PatchPlan = {
	patch_type: PatchType;
	target_entity: "series" | "player" | "team";
	params: PatchParams; // 按 patch_type 的 schema
	constraints?: string[]; // 可选描述性注释
	expected_evidence_type: "AGGREGATED_PERFORMANCE" | "CONTEXT_ONLY";
};
```

### 5.3 System Prompt（冻结关键点）

- 角色：DriftCoach Inference Orchestrator（推理中枢，不是统计/模拟/决策器）。
- 只基于：现有 EvidenceState + central-data 可查询实体。
- 不得：生成 outcome/score/probability；修改 analyzer 阈值；假设不存在的数据。
- 任务：判定证据是否足够；若不足，产出 PatchPlan；若足够，解释为什么可分析。
- 输出：必须为结构化 JSON，符合 `InferencePlan`。

⸻

## 6. Patch 白名单（执行器必须实现）

```ts
type PatchType =
	| "ENUMERATE_SERIES"
	| "ENUMERATE_PLAYERS"
	| "SLICE_SERIES_WINDOW"
	| "AGGREGATE_TEAM_STATISTICS"
	| "AGGREGATE_PLAYER_STATISTICS"
	| "AGGREGATE_SERIES_DISTRIBUTION";
```

- **ENUMERATE_SERIES**：扩大样本池；参数 `window{gte,lte}, tournament?, format?, limit<=200`；产出 `CONTEXT_ONLY`。
- **ENUMERATE_PLAYERS**：为后续聚合收集 roster；参数 `team_id`；仅扩展实体，不直接生成 EvidenceState。
- **SLICE_SERIES_WINDOW**：围绕锚点构造时间窗口；参数 `anchor_series_id, days_before<=180, days_after<=180`；产出 `CONTEXT_ONLY`，用于聚合。
- **AGGREGATE_TEAM_STATISTICS**：team 级聚合；参数 `team_id, series_ids[]`；产出 `AGGREGATED_PERFORMANCE`，含 `aggregation_unavailable`。
- **AGGREGATE_PLAYER_STATISTICS**：player 级聚合；参数 `player_id, series_ids[]`；同上。
- **AGGREGATE_SERIES_DISTRIBUTION**：分布背景；参数 `series_ids[], group_by (format|tournament|time_bucket)`；产出 `AGGREGATED_PERFORMANCE`。

执行器额外约束：
- `max_patches_per_query = 2`（超出直接截断并标记）。
- 全局 rate limit / cooldown（避免高频触发）。

EvidenceState 追加字段：`trace_id`（链路追踪）、`origin`（来源：ai-patch / grid / mock）。
`context.evidence` 追加：`delta_states`、`delta_by_type`、`patch_success_rate`。

**禁止**：推断 WIN/LOSS、写入 analyzer、改阈值、生成概率结论。

⸻

## 7. 工作分解与时间线（10 天 MVP）

- D1-D2：落地 AI orchestrator
	- 写 prompt & Pydantic schema 校验；接入现有 `driftcoach/llm` 封装；加入 mock fallback。
	- 单元测试：给定 mock input，产出合规 JSON；非法字段应被拒绝。

- D2-D4：Patch Executor + 数据通路
	- 新建 `patch_executor.py`：按白名单转成 `build_plan/execute_plan` 调用；写入 EvidenceState（复用 `build_states`）。
	- 记录 provenance；在 mock 模式下用 `frontend/mocks/demo.json` 或 fixtures 生成虚拟 EvidenceState（不可造假 outcome）。

- D3-D5：`/api/coach/query`
	- 在 `driftcoach/api.py` 增加路由、请求体验证、失败 fallback、日志。
	- 响应体包含 `assistant_message`、provenance、最新分析结果。
	- 简单速率/超时保护。

- D4-D6：Frontend Coach Chat Panel
	- 在 `frontend/components` 增加面板与 API hook；渲染 AI 解释与 provenance。
	- 上半区沿用现有分析面板，刷新数据。

- D6-D8：验收与观测
	- E2E（mock）：输入 query → 返回 `EVIDENCE_INSUFFICIENT` + 触发 mock patch → 分析刷新。
	- E2E（grid，若有密钥）：真实调用 central-data，日志可见 patch why/what/result。
	- README 更新：约束、Patch 白名单、API 示例。

- D9-D10：稳定化
	- 错误处理、超时、LLM 重试；前端 UX 收敛；补充缺失单测。

⸻

## 8. 验收标准（可检查）

- 调用 `/api/coach/query`：
	- 若证据不足：返回 `EVIDENCE_INSUFFICIENT`，列出 `missing_evidence`，至少执行 1 个合规 Patch，并在 provenance 中记录。
	- 若证据充分：返回 `EVIDENCE_SUFFICIENT`，`proposed_patches` 为空或缺省，AI 解释说明充分原因。
	- 返回体包含最新 `insights/review/whatIf`；不可包含胜负/概率猜测。
- Patch 执行：
	- 白名单外的 patch 请求直接拒绝并记录。
	- aggregation 不可用时返回 `aggregation_unavailable=true` 与原因，不造假数据。
- 前端：
	- Coach Chat 输入可触发请求；AI 解释和 provenance 可见；分析面板随响应刷新。
- 日志：
	- 每次请求打印 evidence counts、by_type、schema missing、patch why/what/result。
- 测试（最少）：
	- 单测 1：LLM 输出 schema 校验。
	- 单测 2：Patch Executor 对非法 patch_type 拒绝。
	- 单测 3：/api/coach/query mock 路径返回结构完整。

⸻

## 9. 立即行动（今日起）

1) 在 `driftcoach/api.py` 创建 `/api/coach/query` 路由骨架，接线 mock 数据路径。
2) 起草 `driftcoach/llm/orchestrator.py`（prompt + schema 校验 + mock 输出）。
3) 起草 `driftcoach/adapters/grid/patch_executor.py`（仅 ENUMERATE_SERIES、AGGREGATE_TEAM_STATISTICS 两个 happy path + 其它 TODO）。
4) 前端新增 `CoachChatPanel` 占位组件 + 调用新 API 的 hook。
5) README 增补：约束、Patch 白名单、API 示例链接到本文件。

⸻

## 10. 一句话定义（保留）

DriftCoach 是一个由教练问题驱动的推理系统，通过 AI 生成挖掘动机、后端执行事实补全，让分析器在真实证据中逐步被养活的电竞教练平台。



